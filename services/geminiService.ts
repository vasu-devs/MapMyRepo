import { AIAnalysisResult, FileSystemNode, NodeType } from "../types";

const getApiKey = () => {
  const apiKey = import.meta.env.VITE_GEMINI_API_KEY || (typeof process !== 'undefined' ? process.env.GEMINI_API_KEY : undefined);
  if (!apiKey) {
    console.error("Error: VITE_GEMINI_API_KEY is missing.");
    return null;
  }
  return apiKey;
};

const callGemini = async (prompt: string): Promise<string> => {
  const apiKey = getApiKey();
  if (!apiKey) return "Error: API Key is missing. Please check .env.local";

  // Fallback strategy: Try confirmed available models
  // Based on user's API list: gemini-2.0-flash, gemini-flash-latest, gemini-pro-latest
  const models = ["gemini-2.0-flash", "gemini-flash-latest", "gemini-pro-latest"];
  let lastError = "";

  for (const model of models) {
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;

    try {
      const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contents: [{ parts: [{ text: prompt }] }]
        })
      });

      if (!response.ok) {
        const errText = await response.text();
        console.warn(`Model ${model} failed (${response.status}):`, errText);
        lastError = `Error ${response.status} (${model}): ${errText}`;
        continue; // Try next model
      }

      const data = await response.json();
      const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
      if (!text) {
        lastError = "Error: No content generated by AI.";
        continue;
      }

      return text;

    } catch (error: any) {
      console.error(`Model ${model} network error:`, error);
      lastError = `Network Error (${model}): ${error.message || error}`;
    }
  }

  return lastError || "Error: All models failed to respond.";
};

// Helper to create a string representation of the tree for the AI
export const generateTreeString = (node: FileSystemNode, depth: number = 0): string => {
  const indent = '  '.repeat(depth);
  let result = `${indent}- ${node.name} (${node.type})\n`;

  if (node.children) {
    if (depth < 4) {
      node.children.forEach(child => {
        result += generateTreeString(child, depth + 1);
      });
    } else {
      result += `${indent}  ... (more nested items)\n`;
    }
  }
  return result;
};

export const analyzeCode = async (fileName: string, fileContent: string): Promise<AIAnalysisResult | null> => {
  const truncatedContent = fileContent.slice(0, 40000);

  const prompt = `
    Analyze "${fileName}".
    1. Summary: 2 sentences on its architectural role.
    2. Exports: List main functions/classes/components (max 10 words desc).
    Output JSON format ONLY.
    
    CODE:
    ${truncatedContent}
  `;

  const text = await callGemini(prompt);
  if (text.startsWith("Error") || text.startsWith("Network Error")) {
    console.error("Analysis failed:", text);
    return null;
  }

  try {
    // Clean up markdown code blocks if present
    const jsonStr = text.replace(/```json/g, '').replace(/```/g, '').trim();
    return JSON.parse(jsonStr) as AIAnalysisResult;
  } catch (error) {
    console.error("Failed to parse Gemini JSON:", error);
    return null;
  }
};

export const analyzeFolder = async (node: FileSystemNode): Promise<string | null> => {
  const treeMap = generateTreeString(node);
  const prompt = `
        Analyze folder: ${node.name}
        Structure:
        ${treeMap}
        
        Summarize responsibility in 2 sentences.
    `;

  const text = await callGemini(prompt);
  return text;
};

export const askQuestion = async (node: FileSystemNode, rootNode: FileSystemNode | null, question: string): Promise<string> => {
  let context = "";
  if (node.type === NodeType.FOLDER) {
    context = `Folder Structure Map (Recursive):\n${generateTreeString(node)}`;
  } else {
    context = node.content
      ? `Code Content:\n${node.content.slice(0, 30000)}`
      : `File: ${node.name} (Content unavailable)`;
  }

  // Add global context if available
  let globalContext = "";
  if (rootNode) {
    // We use a shallower depth for the global tree to save tokens, but enough to show structure
    globalContext = `Repository Structure (Root): \n${generateTreeString(rootNode, 0)}`;
  }

  const prompt = `
        You are an expert senior software engineer analyzing a codebase.
        
        Target File/Folder: "${node.path}" (${node.type})
        
        Global Repository Context:
        ${globalContext}
        
        Specific Context (The user is looking at this right now):
        ${context}
        
        User Question: "${question}"
        
        Instructions:
        1. Answer directly and authoritatively. Avoid hedging words like "likely", "possibly", "might".
        2. Use the Global Repository Context to understand where this file fits in the bigger picture.
        3. If the answer depends on code not visible in the Specific Context, state clearly what you would expect to find based on standard patterns, but don't guess wildly.
        4. Keep the answer under 150 words. Use Markdown for formatting.
    `;

  return await callGemini(prompt);
};

export const findRelevantFile = async (query: string, allFilePaths: string[]): Promise<string | null> => {
  const pathList = allFilePaths.slice(0, 1000).join('\n');
  const prompt = `
        I have a list of file paths from a software repository.
        The user is asking: "${query}"
        
        Based on the file names, folder structure, and common software conventions, identify the SINGLE file path that is MOST LIKELY to contain the logic or definition the user is looking for.
        
        Return ONLY the full path string. 
        If nothing is relevant, return "null".
        
        File Paths:
        ${pathList}
    `;

  const text = await callGemini(prompt);
  if (!text || text.startsWith("Error") || text.trim() === "null") return null;

  return text.replace(/`/g, '').replace(/'/g, '').replace(/"/g, '').trim();
};